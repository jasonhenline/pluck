<style>
  .components {
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .buttons {
    margin-bottom: 20px;
  }
</style>

<script src="https://cdn.jsdelivr.net/npm/wavefile"></script>

<script>
  // @ts-check

  function getTentFunction(s) {
    return (x) => {
      if (x < s) {
        return x / s;
      } else {
        return (1 - x) / (1 - s);
      }
    };
  }

  function getSineFunction(k) {
    return (x) => {
      return Math.sin(Math.PI * k * x);
    };
  }

  function integrate(f) {
    const dx = 1e-4;
    let result = 0.0;
    for (let x = 0.0; x < 1.0; x += dx) {
      result += f(x) * dx;
    }
    return result;
  }

  function computeTentSineAmplitude({ s, k }) {
    const tentFunction = getTentFunction(s);
    const sineFunction = getSineFunction(k);
    const f = (x) => tentFunction(x) * sineFunction(x);
    return integrate(f);
  }

  function getAmplitudes(s, count) {
    const results = [];
    for (let k = 0; k < count; k++) {
      results.push(computeTentSineAmplitude({ s, k }));
    }
    return results;
  }

  /**
   * Creates an audio element from an air pressure function.
   *
   * @param {(t: number) => number} f A function from time (in seconds) to pressure.
   * @param {number} durationInSeconds The number of seconds over which to sample.
   * @return {HTMLAudioElement}
   */
  function createAudioElement(f, durationInSeconds) {
    const SAMPLES_PER_SECOND = 44100; // standard value used by wav files

    const sampleCount = SAMPLES_PER_SECOND * durationInSeconds;
    const samples = [];
    for (let i = 0; i < sampleCount; i++) {
      samples.push(f(i / SAMPLES_PER_SECOND));
    }

    const wav = new wavefile.WaveFile();
    wav.fromScratch(1, SAMPLES_PER_SECOND, "16", samples);
    const buffer = wav.toBuffer();
    const blob = new Blob([buffer], { type: "audio/wav" });
    const url = URL.createObjectURL(blob);
    return new Audio(url);
  }

  const baseHertz = 440;

  function getFrequencyForSineFunction(k) {
    // Play around here to experiment with dispersion relations.
    return baseHertz * k;
  }

  const amplitude = 32000;

  // The point at which you pluck.
  const s = 0.6180339;

  const overtoneCount = 30;

  // Get the Fourier amplitudes for some k values.
  const componentAmplitudes = getAmplitudes(s, overtoneCount);

  // Create some samples.
  const wavDurationInSeconds = 1.5;

  const overtoneFunction = (t) => {
    let result = 0.0;
    for (let k = 1; k < overtoneCount; k++) {
      const frequency = getFrequencyForSineFunction(k);
      result +=
        amplitude *
        componentAmplitudes[k] *
        Math.sin(2.0 * Math.PI * frequency * t);
    }
    return result;
  };

  const pureFunction = (t) =>
    amplitude * Math.sin(2.0 * Math.PI * baseHertz * t);

  const audio = createAudioElement(overtoneFunction, wavDurationInSeconds);
  const pureAudio = createAudioElement(pureFunction, wavDurationInSeconds);

  /**
   * @param {(x: number) => number} f
   * @param {HTMLCanvasElement} canvasElement
   */
  function drawGraph(f, canvasElement) {
    const margin = 5;
    const height = canvasElement.height - 2 * margin;
    const width = canvasElement.width - 2 * margin;
    const context = canvasElement.getContext("2d");
    if (!(context instanceof CanvasRenderingContext2D)) {
      return;
    }
    context.clearRect(0, 0, canvasElement.width, canvasElement.height);
    // Draw axes.
    context.lineWidth = 3;
    context.strokeStyle = "black";
    context.moveTo(margin, margin + height / 2);
    context.lineTo(margin + width, margin + height / 2);
    context.stroke();

    // Draw function.
    context.strokeStyle = "green";
    context.beginPath();
    context.moveTo(margin, margin + height / 2);
    for (let x = 0.0; x < 1.0; x += 0.01) {
      context.lineTo(margin + x * width, margin + (1.0 - f(x)) * (height / 2));
    }
    context.stroke();
  }

  function drawPluckShape(amplitudes) {
    const pluckShapeCanvas = document.getElementById("pluck-shape");
    if (pluckShapeCanvas instanceof HTMLCanvasElement) {
      const f = (x) => {
        let result = 0.0;
        for (let k = 0; k < amplitudes.length; k++) {
          const amplitude = amplitudes[k];
          const sineFunction = getSineFunction(k);
          result += amplitude * sineFunction(x);
        }
        return result;
      };
      drawGraph(f, pluckShapeCanvas);
    }
  }

  function drawComponent(name, amplitude, k) {
    const canvasElement = document.getElementById(name);
    if (canvasElement instanceof HTMLCanvasElement) {
      const sineFunction = getSineFunction(k);
      drawGraph((x) => amplitude * sineFunction(x), canvasElement);
    }
  }
</script>

<div class="components">
  <div class="buttons">
    <button onclick="pureAudio.play()">Click me to play pure</button>
    <button onclick="audio.play()">Click me to play</button>
  </div>
  <canvas id="pluck-shape" width="300" height="100"></canvas>
  <canvas id="k-1" width="300" height="100"></canvas>
  <canvas id="k-2" width="300" height="100"></canvas>
  <canvas id="k-3" width="300" height="100"></canvas>
  <canvas id="k-4" width="300" height="100"></canvas>
  <canvas id="k-5" width="300" height="100"></canvas>
  <canvas id="k-6" width="300" height="100"></canvas>
</div>

<script>
  drawPluckShape(componentAmplitudes);
  drawComponent("k-1", componentAmplitudes[1], 1);
  drawComponent("k-2", componentAmplitudes[2], 2);
  drawComponent("k-3", componentAmplitudes[3], 3);
  drawComponent("k-4", componentAmplitudes[4], 4);
  drawComponent("k-5", componentAmplitudes[5], 5);
  drawComponent("k-6", componentAmplitudes[6], 6);
</script>
